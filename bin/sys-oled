#!/usr/bin/env python3

import glob
import os
import signal
import sys
import time
from collections import OrderedDict
from configparser import ConfigParser
from datetime import datetime

import psutil
from luma.core import cmdline, error
from luma.core.render import canvas
from PIL import Image, ImageFont

# Load presets
contrast = 255
refresh = 10
show_logo = 'yes'
net_name = 'eth0'
s1_name = 'sd'
s1_path = '/'

# emergency signal thresholds
max_cpu_temp = 90.0
low_fan_rpm = -99 # disabled
show_cpu_temp = 'yes'
show_cpu_load = 'yes'
show_fan_rpm = 'yes'
storage_sections = []
show_load_average = []

# Get the number of CPU cores
cpu_count = os.cpu_count()


# Load config file
config_file = '/etc/sys-oled.conf'

def load_sections_with_prefix(config : ConfigParser, prefix, as_ordered_dict=True):
    """
    Loads sections from a ConfigParser object that match a given prefix.

    Args:
        config (configparser.ConfigParser): The existing ConfigParser object.
        prefix (str): The prefix to match section names (e.g., "disk.").
        as_ordered_dict (bool): Whether to return results as an OrderedDict (default: True).

    Returns:
        OrderedDict or List[dict]: Matching sections as an ordered dictionary or a list of dictionaries.
    """
    # Collect matching sections
    result = OrderedDict() if as_ordered_dict else []
    for section in config.sections():
        if section.startswith(prefix):
            # Extract the section name after the prefix (e.g., "disk.disk1" -> "disk1")
            section_key = section[len(prefix):]
            section_data = {key: value for key, value in config.items(section)}
            
            if as_ordered_dict:
                result[section_key] = section_data
            else:
                result.append(section_data)

    return result


if os.path.isfile(config_file):
    config = ConfigParser()
    config.read(config_file)
    contrast = int(config.get('main', 'contrast'))
    refresh = float(config.get('main', 'refresh'))
    show_logo = config.get('main', 'show_logo')
    show_cpu_temp = config.get('main', 'show_cpu_temp') if config.has_option('main', 'show_cpu_temp') else show_cpu_temp
    show_cpu_load = config.get('main', 'show_cpu_load') if config.has_option('main', 'show_cpu_load') else show_cpu_load
    show_fan_rpm = config.get('main', 'show_fan_rpm') if config.has_option('main', 'show_fan_rpm') else show_fan_rpm
    max_cpu_temp = float(config.get('device', 'max_cpu_temp')) if config.has_option('device','max_cpu_temp') else max_cpu_temp
    low_fan_rpm = float(config.get('device', 'low_fan_rpm')) if config.has_option('device','low_fan_rpm') else low_fan_rpm
    net_name = config.get('device', 'network_name')
    if config.has_option('main','show_load_average'):
        show_load_average = config.get('main','show_load_average')
        show_load_average = [int(item.strip()) for item in show_load_average.split(",")]
    
    storage_sections = load_sections_with_prefix(config, "storage.", as_ordered_dict=False)
        
# Load font
font_path = os.path.abspath(os.path.join(os.path.dirname(__file__),
                                         '../share/sys-oled', 'C&C Red Alert [INET].ttf'))
font_size = 12
font = ImageFont.truetype(font_path, font_size)
font_mid_size = 18
font_mid = ImageFont.truetype(font_path, font_mid_size)
font_big_size = 48
font_big = ImageFont.truetype(font_path, font_big_size)

def get_device(actual_args=None):
    if actual_args is None:
        actual_args = sys.argv[1:]
    parser = cmdline.create_parser(description='luma.core arguments')
    args = parser.parse_args(actual_args)

    if args.config:
        config = cmdline.load_config(args.config)
        args = parser.parse_args(config + actual_args)

    try:
        device = cmdline.create_device(args)
    except error.Error as e:
        parser.error(e)

    return device

def bytes2human(n):
    symbols = ('K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
    prefix = {}
    for i, s in enumerate(symbols):
        prefix[s] = 1 << (i + 1) * 10
    for s in reversed(symbols):
        if n >= prefix[s]:
            value = float(n) / prefix[s]
            if s in ['K', 'M']:
                return '%d%s' % (int(value), s)
            else:
                return '%.1f%s' % (value, s)
    return "%sB" % n

def get_fan_speeds():
    fan_files = glob.glob('/sys/class/hwmon/hwmon*/fan*_input')
    speeds = {}
    for fan_file in fan_files:
        with open(fan_file, 'r') as f:
            fan_speed = f.read().strip()
            speeds[fan_file] = f"{fan_speed}"
    return speeds
    
def cpu_usage():
    load = psutil.cpu_percent(interval=None)
    temp = psutil.sensors_temperatures()['cpu_thermal']
    uptime = datetime.now().replace(second=0, microsecond=0) - datetime.fromtimestamp(psutil.boot_time())
    return "ld: %s%% T: %sC up: %s" \
           % (str(load).split('.')[0], str(temp[0].current).split('.')[0], str(uptime).split(',')[0][:-3])

def cpu_load_from_loadavg(index: int):
    # Read the 1-minute load average from /proc/loadavg
    with open('/proc/loadavg', 'r') as f:
        load_avg_1 = float(f.read().split()[index])  # Get the 1-minute load average

    # Calculate the percentage load
    cpu_load_percentage = (load_avg_1 / cpu_count) * 100.0

    return cpu_load_percentage

def cpu_load_average(lav_index: int):
    load = float(cpu_load_from_loadavg(lav_index))
    return ("%.1f%%" if load < 10 else "%.0f%%") % float(load), float(load)

def cpu_load():
    load = psutil.cpu_percent(interval=None)
    return ("%.1f%%" if load < 10 else "%.0f%%") % load, load

def cpu_temp():
    temp = psutil.sensors_temperatures()['cpu_thermal']
    temp = float(str(temp[0].current).split('.')[0])
    return "%.1f\u00B0" % temp, temp

def fan_speed():
    fan_speeds = get_fan_speeds()
    first = next(iter(fan_speeds))
    first = fan_speeds[first]
    return first, int(first)

def mem_usage():
    usage = psutil.virtual_memory()
    return "mem: %s / %s - %.0f%%" \
           % (bytes2human(usage.used), bytes2human(usage.total), usage.percent)

def disk_usage(name, dir):
    usage = psutil.disk_usage(dir)
    return name + ": %s / %s - %.0f%%" \
           % (bytes2human(usage.used), bytes2human(usage.total), usage.percent)

def emergency_check(device, draw_fn, interval=0.5):
    """
    Flashes an emergency signal on the LCD by alternating between the callable-drawn
    content and a blank screen, until the callable returns False.
    
    Args:
        device: The luma.core device object representing the LCD.
        draw_fn: Any callable that takes the device as an argument and returns a boolean.
                 - True: Continue flashing.
                 - False: Stop flashing.
        interval: The time interval in seconds between flashing (default: 0.5 seconds).
    """
    while True:
        cont = draw_fn(device)
        if not cont:
            break  # Stop if the callable returns False
        
        time.sleep(interval)
        
        # Clear the screen (blank state)
        with canvas(device) as draw:
            pass  # Blank the screen
        time.sleep(interval)

def network(iface):
    addr = psutil.net_if_addrs()[iface]
    return "%s: %s" \
           % (iface, addr[0].address)


def host_time():
    now = datetime.now()
    return "" + now.strftime("%Y-%m-%d %H:%M")

def display_info(device):
    with canvas(device) as draw:
        draw.text((0, 0), cpu_usage(), font=font, fill="white")
        draw.line((0, 13) + (128, 13), fill="white")
        draw.text((0, 15), mem_usage(), font=font, fill="white")
        draw.text((0, 27), disk_usage(s1_name, s1_path), font=font, fill="white")
        if 's2_name' in globals():
            draw.text((0, 39), disk_usage(s2_name, s2_path), font=font, fill="white")
            draw.text((0, 51), network(net_name), font=font, fill="white")
        else:
            draw.text((0, 39), network(net_name), font=font, fill="white")

def display_cpu_load(device):
    loads, loadf = cpu_load()
    with canvas(device) as draw:
        draw.text((0, 5), "CPU", font=font_mid, fill="white")
        draw.text((0, font_mid_size + 5), "load", font=font_mid, fill="white")
        draw.text(((2 * font_mid_size), 0), loads, font=font_big, fill="white")
        return loadf

def display_cpu_load_average(device, lav_index: int):
    loads, loadf = cpu_load_average(lav_index)
    with canvas(device) as draw:
        draw.text((0, 5), "CPU", font=font_mid, fill="white")
        draw.text((0, font_mid_size + 5), f"av {lav_index}", font=font_mid, fill="white")
        draw.text(((2 * font_mid_size), 0), loads, font=font_big, fill="white")
        return loadf

def display_temp(device):
    temp, tempf = cpu_temp()
    with canvas(device) as draw:
        draw.text((0, 5), "CPU", font=font_mid, fill="white")
        draw.text((0, font_mid_size + 5), "temp", font=font_mid, fill="white")
        draw.text(((2 * font_mid_size), 0), temp, font=font_big, fill="white")
        return tempf

def display_fan_speed(device):
    fss, fsi = fan_speed()
    with canvas(device) as draw:
        draw.text((0, 5), "Fan", font=font_mid, fill="white")
        draw.text((0, font_mid_size + 5), "rpm", font=font_mid, fill="white")
        draw.text(((2 * font_mid_size), 0), fss, font=font_big, fill="white")
        return fsi

def display_storage(device, storage: dict):
    usage = psutil.disk_usage(storage['dir'])
    txt = "%.0f%%" % usage.percent
    with canvas(device) as draw:
        draw.text((0, 5), "Disk", font=font_mid, fill="white")
        if 'name' in storage:
            draw.text((0, font_mid_size + 5), storage['name'], font=font_mid, fill="white")
        draw.text(((2 * font_mid_size), 0), txt, font=font_big, fill="white")

def logo(device, msg):
    img_path = os.path.abspath(os.path.join(os.path.dirname(__file__),
                                            '../share/sys-oled', 'armbian-oled.png'))
    logo = Image.open(img_path).convert("RGBA")

    with canvas(device) as draw:
        draw.bitmap((0, -2), logo, fill="white")
        draw.text((0, 50), msg, font=font_big, fill="white")

def sigterm_handler():
    sys.exit(0)

signal.signal(signal.SIGTERM, sigterm_handler)

# emergency callables need to return if we're still in an  emergency state
def emergency_cpu_temp(device):
    temp = display_temp(device)
    return temp > max_cpu_temp

def emergency_fan_rpm(device):
    fan_speed = display_fan_speed(device)
    return fan_speed <= low_fan_rpm

def main():
    while True:
        if show_cpu_temp:
            emergency_check(device, emergency_cpu_temp)
            time.sleep(refresh)
        if show_fan_rpm:
            emergency_check(device, emergency_fan_rpm)
            time.sleep(refresh)
        if show_cpu_load:
            display_cpu_load(device)
            time.sleep(refresh)
        for lav_index in show_load_average:
            if int(lav_index) >= 0 and int(lav_index) <= 2:
                display_cpu_load_average(device, int(lav_index))
                time.sleep(refresh)
        for storage in storage_sections:
            if 'dir' in storage:
                display_storage(device, storage)
                time.sleep(refresh)

        if show_logo == "yes":
            logo(device, host_time())
            time.sleep(refresh / 2)

if __name__ == "__main__":
    try:
        device = get_device()
        device.contrast(contrast)
        main()
    except KeyboardInterrupt:
        pass
